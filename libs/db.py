#!/usr/bin/python
# -*- coding: utf -*-

# pymongo
from pymongo import Connection
from bson.objectid import ObjectId

db = None

def init_connection(database):
    '''initialize new database connection'''
    global db

    connection = Connection()
    db = connection[database]

def database_name():
    '''get database name'''
    return db.database.database.name

class Collection:
    '''a generic collection api'''

    def paginator(self, query, per_page):
        '''link to Paginator class'''
        return Paginator(query, per_page)

    def find_one(self, id=None, where=None):
        if id:
            return db[self.table].find_one({"_id": ObjectId(id)})
        else:
            return db[self.table].find_one(where)

    def find_all(self):
        return db[self.table].find()

    def find(self, where, sort=None):
        if sort:
            if isinstance(sort, (dict)):
                for key,order in sort.items():
                    return db[self.table].find(where).sort(key, order)
            else:
                return db[self.table].find(where).sort(sort)
        else:
            return db[self.table].find(where)

    def save(self, dict):
        return db[self.table].insert(dict)

    def update(self, id, what, dict, operation="$set"):
        db[self.table].update({'_id': ObjectId(id)}, {operation: {what: dict}})

    def replace(self, id, dict):
        db[self.table].update({'_id': ObjectId(id)}, dict, True)

    def remove(self, id):
        db[self.table].remove({'_id': ObjectId(id)})

    def increment(self, id, what, value):
        db[self.table].update({'_id': ObjectId(id)}, {"$inc": {what: value}})

class Paginator(object):
    def __init__(self, query, per_page):
        from math import ceil

        self.query = query
        self.per_page = per_page
        self._count = query.count()
        self.page_count = int(ceil(float(self._count) / per_page))

    def page_range(self):
        """Return a 1-based list of page numbers valid for this Paginator"""
        return range(1, self.page_count + 1)

    def page(self, page_number):
        """1-based access to pages"""
        if not isinstance(page_number, int):
            try:
                page_number = int(page_number)
            except:
                raise Exception("Page numbers must be integers.")
        if page_number < 1:
            raise Exception("%s is less than 1." % page_number)
        if page_number > self.page_count:
            #raise Exception("Page %s contains no results." \
            #    % page_number)
            return None

        # apply pagination offsets and limits
        start_offset = self.per_page * (page_number-1)
        end_offset = self.per_page + start_offset
        query = self.query[start_offset:end_offset]

        # return Page object
        object_list = list(query)
        return Page(object_list=object_list, page_number=page_number, page_count=self.page_count, all_objects_count=self._count,
                    per_page=self.per_page)

class Page(object):
    def __init__(self, object_list, page_number, page_count, all_objects_count, per_page):
        """A page of data generated by Paginator"""
        self.object_list = object_list
        self.page_number = page_number
        self.page_count = page_count
        self.all_objects_count = all_objects_count
        self.per_page = per_page

    def __repr__(self):
        return u"<Page %s of %s>" % (self.page_number, self.page_count)

    def has_previous(self):
        return self.page_number > 1

    def has_next(self):
        return self.page_number < self.page_count

    def has_other_pages(self):
        return self.all_objects_count > self.per_page

    def next_page_number(self):
        return self.page_number + 1

    def previous_page_number(self):
        return self.page_number - 1
